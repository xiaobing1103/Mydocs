# vue插值语法



- 模板解析: 解析模板中插值语法和指令语法

  将vm添加到`this.$vm`上:为了给其他函数使用

  `this.$vm = vm`

  判断el是否式元素节点:是-->就返回这个元素 不是-->获取元素并返回

  所有文档碎片节点的子节点就是el元素的子节点

  将解析后的文档碎片节点添加到页面中生效

  优点:DOM操作都是在文档碎片节点中操作的(也就是说,在内存中操作的)整体性能比较好

  取出el所有的子节点

  nede就是每一个子节点

  text 取出子节点的文本内容

  定义一个用来匹配 插值语法的正则表达式

  判断子节点是否是元素节点

   再判断子节点是否文本节点

  如果是,再判断节点的文本内容是否包含插值语法

  解析插值语法

  nede当前遍历子节点

  RegExp.$1-->匹配(.*)里面的内容-->插值语法中的表达式-->表达式

  

  

  

  

  详细版

  从`new Compile()`开,一共三个步骤

  1.将el的所有子节点添加到文档碎片节点中

  2.一旦节点添加文档碎片中,节点就会自动从DOM消失

- 解析,编译文档碎片模板代码

  - 取出子节点进行遍历
  - 判断节点是否是元素节点
    - 如果是元素节点,进行解析元素的指令语法
    - 取出元素的所有属性节点,进行遍历
    - 判断是否是指令属性(v-)
      - 如果是,还要判断是否是事件指令(on)
        - 如果是,就是事件指令,给元素绑定事件和相应的回调函数,回调函数通过bind方法改变this指向为vm
          - 如果不是，就是一般指令
            - compileUtil['xxx'] --> bind --> xxxUpdaterFn --> 操作 DOM 元素
            - 比如：v-text 操作元素 textContent 属性，值为表达式的值
          - 注意最后会 new watcher()，会将更新数据的 updater 函数传入，这个 new Watcher 建立响应式联系的入口
        - 解析完指令后，会将指令属性给移除掉
      - 如果不是，就不处理这个属性
    - 再判断节点是否是文本节点且包含插值语法
      - 满足条件，进行解析文本的插值语法
        - 和`v-text`指令解析类似,都是最终调用`textUpdater`方法更新元素`textContent`的值
        - 注意 最后会new watcher()
        
      - 最后判断当前节点是否有子节点,如果有就要递归调用,对所有子节点编译
        
        - 目的:为了解析模板中所有的节点
        
      - 将解析后的文档碎片代码添加到el中生效
      
        

- new Watcher()是如何建立起响应式联系的

  - new Watcher() 此时会去原数据上读取表达式值

  - 会触发数据劫持阶段给原数据属性绑定的 get 方法

  - get 方法中会调用 dep.depend()，此时就会建立响应式联系

  - 响应式联系：会在 dep 中保存相应的 watcher，wacher 中保存相应的 dep
    - dep 中保存相应的 watcher 的目的：为了将来更新数据时，调用 dep 中的所有 watcher.update 方法去更新用户界面
    - wacher 中保存相应的 dep 的目的：为了防止 dep 重复保存相同的 watcher







- 响应式触发：

- 当更新数据时

  - 首先触发 数据代理阶段给 this 设置的属性的 set 方法，内部实际操作的是 data 原数据

  - 操作原数据，又会触发 数据劫持阶段给原数据属性绑定的 set 方法,

  - set 方法中会更新数据，同时调用 dep.notify 方法

  - dep.notify 方法内部会遍历所有保存的 watcher 去调用更新用户界面的方法

  - 从而实现，数据发生变化，页面也发生变化，达到响应式

