# [HTTP课程]

## [第1章：HTTP协议简介]

### [1.1 HTTP协议是什么]

- 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。
- **Hyper Text Transfer Protocol（超文本传输协议）**,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。
- 客户端与服务端通信时传输的内容我们称之为报文。
- HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文。客户端发送给服务器的称为“请求报文”，服务器发送给客户端的称为“响应报文”。

### [1.2 浏览器查看network]

#### [1.2.1 响应的内容]

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcw5y1yyjuj315k0fy3zb.jpg)

- Headers:报文的头部
- Preview:预览响应的数据
- Response:响应的具体数据
- Initiator:初始化内容
- Timing：时间
- Cookies:携带的cookie

#### [1.2.2 响应头的内容]

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcw64ze0g0j30b804cq2s.jpg)

- General:通用头部
- Response Headers:响应头部

- Request Headers:请求头部

### [1.3 什么是HTTP报文]

- 它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。

- **HTTP报文的流动方向：**一次HTTP请求，HTTP报文会从“客户端”流到“代理”再流到“服务器”，在服务器工作完成之后，报文又会从“服务器”流到“代理”再流到“客户端”

- 报文的语法：

  所有的HTTP报文都可以分为两类，

  请求报文和响应报文

  。请求和响应报文的基本报文结构大致是相同的，只有起始行的语法有所不同。

  - **请求报文：**它会向Web服务器请求一个动作
  - **响应报文：**它会将请求的结果返回给客户端。

### [1.4 报文包]

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcx3mvo963j31hu0gstcv.jpg)

#### [1.4.1 请求报文包]

##### [1.4.1.1 GET请求报文包]

1. 请求报文首行

   - GET http://localhost:3000/?name=lily HTTP/1.1
   - GET 请求方式是GET（其他的方式：GET(查) POST(增)PUT(改)DELETE(删除)OPTIONS(跨域请求)）
   - http://localhost:3000/ 请求服务器地址
   - HTTP/1.1 HTTP协议/1.1版本
   - ?name=lily :请求参数，也叫查询字符串（query String）

2. 请求报文头部

   - Host: localhost:3000 访问服务器的主机名
   - Connection: keep-alive 保持长链接（保持TCP连接）实际上它是一种TCP复用，每次http请求都需要tcp三次握手，浪费资源和时间，因此我们可以保持tcp通道连接一段时间，这样一次tcp连接就可以维持几次http请求
   - Cache-Control: max-age=0 缓存
   - Upgrade-Insecure-Requests: 1 允许https协议
   - User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 用户代理：客户端信息通过User-Agent来区分浏览器
   - Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9代表客户端允许接收的文件类型
   - Accept-Encoding: gzip, deflate, br 代表客户端允许接收文件的压缩格式
   - Accept-Language: zh-CN,zh;q=0.9 代表客户端支持语言
   - Cookie: _ga=GA1.1.444464845.1583242232 cookie 会话控制

3. 请求报文空行

4. 请求报文体

   POST请求的请求数据 （GET请求会在请求首行中）

##### [1.4.1.2 POST请求报文包]

1. 请求报文首行

   POST http://localhost:3000/ HTTP/1.1

2. 请求报文头部

   - Host: localhost:3000
   - Connection: keep-alive
   - Content-Length: 28
   - Cache-Control: max-age=0
   - Origin: [http://localhost:52330](http://localhost:52330/)
   - Upgrade-Insecure-Requests: 1
   - Content-Type: application/x-www-form-urlencoded form表单提交的数据

3. 请求体类型

   - User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36
   - Sec-Fetch-Dest: document
   - Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
   - Sec-Fetch-Site: same-site
   - Sec-Fetch-Mode: navigate
   - Sec-Fetch-User: ?1
   - Referer: http://localhost:52330/03.nodejs/day03/form.html
   - Accept-Encoding: gzip, deflate, br
   - Accept-Language: zh-CN,zh;q=0.9
   - Cookie: _ga=GA1.1.444464845.1583242232

4. 空行

5. 请求报文体

   username=aaaa&password=bbbbb

#### [1.4.2 响应报文包]

1. 响应报文首行
   - HTTP/1.1 200 OK
     - HTTP/1.1 协议名/版本号
     - 200 响应状态码
     - OK 响应信息
2. 响应报文头部
   - Content-Type: text/html;charset=utf8
     - 响应体类型
   - Date: Fri, 06 Mar 2020 05![51](https://github.githubassets.com/images/icons/emoji/51.png)45 GMT
     - 响应时间
   - Connection: keep-alive
   - Content-Length: 25
     - 响应体长度
3. 空行
4. 响应报文体

### [1.5 请求方式]

请求方式 GET（查询） POST（新增） PUT（修改） DELETE（删除） OPTIONS（预检）

- 请求地址 请求服务器地址 协议名://域名（ip地址）:端口号/路径
- 请求参数
  - GET参数：请求首行
    - 也叫做查询字符串（querystring）参数
    - ?username=admin&password=123456
    - ?key=value&key=value&key=value
  - POST参数：请求体
    - 也叫做请求体（body）参数
    - username=aaaa&password=bbbbb

## [第2章：重要报文]

### [2.1 报文格式]

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcw6sjgnzcj30n606smxv.jpg)

### [2.2 Content-Type]

`Content-Type`实体头部用于指示资源的MIME类型。

在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。

MIME类型也叫媒体类型，是一种标准，用来表示文档、文件或字节流的性质和格式。

重要的MIME类型：

| MIME类型                              | 含义                                  |
| ------------------------------------- | ------------------------------------- |
| **application/octet-stream**          | **应用程序文件**                      |
| **text/plain**                        | **文本文件**                          |
| **text/css**                          | **css\****文件**                      |
| **text/html**                         | **html\****文件**                     |
| **application/javascript**            | **js\****文件**                       |
| **image/gif**                         | **GIF** **图片**                      |
| **image/jpeg**                        | **JPEG/JPG** **图片**                 |
| **image/png**                         | **PNG** **图片**                      |
| **image/svg+xml**                     | **SVG\****图片 (矢量图)**             |
| **image/x-icon**                      | **icon\****图片**                     |
| **application/json**                  | **json\****文件**                     |
| **multipart/form-data**               | 上传文件                              |
| **application/x-www-form-urlencoded** | Form表单格式                          |
| **audio/webm**                        | **WebM** **音频文件格式**             |
| **video/webm**                        | **WebM\****视频文件格式的音视频文件** |

### [2.3 Status]

HTTP 响应状态代码（status）指示特定 HTTP 请求是否已成功完成。响应分为五类：

- 信息响应(100–199)
  - 100: 请求继续。表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略
  - 101: Switching Protocol 服务器应客户端升级协议的请求（Upgrade请求头）正在进行协议切换。在使用 WebSockets 时会用到协议切换。
  - 102: 此代码表示服务器已收到并正在处理该请求，但没有响应可用。
  - 103: Early Hints 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。
- 成功响应(200–299)
  - 200: 请求成功。 但是PUT** 和 **DELETE** 的请求成功通常并不是响应**200 OK**的状态码而是 **204 No Content 表示无内容(或者 201 Created表示一个资源首次被创建成功)**。
  - 201: Created 表示请求已经被成功处理，并且创建了新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应
  - 202: Accepted表示服务器端已经收到请求消息，但是尚未进行处理。
  - 203: 表示服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝
  - **204 No Content** 该状态码表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新
  - **206 Partial Content** 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求
- 重定向(300–399)
  - 301: Moved Permanently， 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI
  - **302 Found** 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。
  - **304 Not Modified** 请求资源未被修改，浏览器将会读取缓存
- 客户端错误(400–499)
  - **400 Bad Request** 该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。
  - **401 Unauthorized** 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。
  - **403 Forbidden** 该状态码表明对请求资源的访问被服务器拒绝了
  - **404 Not Found** 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
- 服务器错误 (500–599)。
  - **500 Internal Server Error** 该状态码表明服务器端在执行请求时发生了错误。
  - **503 Service Unavailable** 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

### [2.4 缓存]

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。

- 禁止缓存

  缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。

  Cache-Control: no-store

- 私有缓存和公共缓存

  Cache-Control: private 私有缓存：该响应只能被浏览器缓存。

  Cache-Control: public 公共缓存：该响应可以被任何中间人（比如代理服务器、CDN等）缓存。

- 强制缓存

  Http 1.1 Cache-Control

  如：Cache-Control: max-age=3600, public 表示强制缓存资源1小时，并且是公共缓存

  Http 1.0 Expires

  如：Expires: Thu, 03 Mar 2020 06![55](https://github.githubassets.com/images/icons/emoji/55.png)02 GMT 表示强制缓存资源到北京时间2020年3月3日16![55](https://github.githubassets.com/images/icons/emoji/55.png)02（中国位于东八区）

- 协商缓存

  ETag / Last-Modified

  If-None-Match / If-Modified-Since

### [1.3.5 OSI七层模型的划分]

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcwxgrtcu8j30hg0iogou.jpg)

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcxbylgp4jj31200tejw3.jpg)

- 应用层

  OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等

  > 实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等

- 表示层

  表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一

  > 由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。

- 会话层

  会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成

  > 会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。

- 传输层

  传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路,我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

  > 传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局

- 网络层

  本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础

  > 网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点

- 数据链路层

  数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输媒体及其连接.媒体是长期的,连接是有生存期的.在连接生存期内,收发两端可以进行不等的一次或多次数据通信.每次通信都要经过建立通信联络和拆除通信联络两过程.这种建立起来的数据收发关系就叫作数据链路。并进行差错检测

- 物理层

  实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

  > 快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。

## [第3章：相关面试题]

### [3.1 从url输入地址到最终网页渲染，中间发生了什么？]

1. DNS查询 / 解析

- 将域名地址解析成ip地址（4个缓存 1个递归查询）
  - 浏览器DNS缓存
  - 计算机DNS缓存
  - 路由器DNS缓存
  - 网络运营商DNS缓存
    - .com --> d.com --> c.d.com --> b.c.d.com --> a.b.c.d.com

1. TCP连接： TCP三次握手

- 第一次握手：浏览器发送给服务器，告诉服务器我准备好了，将要发送请求 syn

- 第二次握手：服务器发送给浏览器，告诉浏览器我也准备好了，需要和你再次确认一下 syn + ack

- 第三次握手：浏览器发送给服务器，告诉服务器确认完毕，马上发送请求 ack

  > Connection: keep-alive 保持长连接（保持TCP连接）

1. 发送请求

   按照HTTP协议的规定，生成请求报文，浏览器将请求报文发送给服务器

   浏览器将请求报文发送给服务器

2. 返回响应

   按照HTTP协议的规定，生成相应报文，服务器将请求报文发送给客户端

3. 渲染页面：

   *看3.2详情*

4. 断开连接：TCP四次挥手

   第一次挥手：浏览器发送给服务器，告诉服务器请求报文发送完毕

   第二次挥手：服务器发送给浏览器，告诉浏览器请求报文接受完毕，可以等待断开

   第三次挥手：服务器发送给浏览器，告诉浏览器响应报文发送完毕

   第四次挥手：浏览器发送给服务器，告诉服务器响应报文接受完毕，可以断开连接了

 服务器断开连接 再是浏览器断开连接

### [3.2 浏览器渲染]

1. 构建 DOM 树

   - 因为浏览器无法直接理解和使用 html 文件，所以需要将 html 文件转为浏览器能够理解的结构 DOM 树
   - 输入：html 文件
   - 输出：DOM 树
   - 操作过程：解析 html 结构为浏览器可以理解的 DOM 树结构，期间会去下载次级资源以及执行 js 代码。

2. 样式计算

   样式计算是为了获取每个节点的样式，其主要分为三步来完成。

   - 转成浏览器可以理解的数据结构styleSheets，可以在开发者工具上通过 document.styleSheets 打印出来。只需要了解到主进程会将 css 代码转成浏览器可以理解的结构，这个结构支持查询和修改。可以在开发者工具上通过 document.styleSheets 打印出来。

   - 将 css 转成标准化的样式

     比如 rem 转成 px、bule 转成 rgba 等。

   - 最后是计算每个节点的样式。

     这一步骤涉及到 css 的继承规则和层叠规则。有些属性是可以被子元素继承的，有些属性是会覆盖前面的样式

3. 布局阶段

   想要渲染一个完整的页面，仅知道 DOM 树和 DOM 树元素的样式还是不够的，我们还需要知道 DOM 树中元素的位置。同样的布局这个子阶段也分为两个过程操作，分别是合成布局树和计算节点位置。

   - 合成布局树

     布局树和 DOM 树类似，不过布局树上只包含会显示的节点内容，不包含 display: none 样式的元素。只包含可见节点

   - 计算节点位置

     有了一颗完成的布局树，主线程会计算出每个元素的位置信息以及盒子大小

4. 分层

   因为页面有很多复杂的效果，比如滑动、z-idnex 等。为了更好的实现这些效果，渲染引擎**主线程**还需要为特定的阶段生成专用的图层，并生成一颗对应的**图层树**。

   - 拥有层叠上下文属性的元素会单独生成一个图层。

     - 3D 或透视变换的 css 属性
     - 使用加速视频解码的 video 元素
     - canvas 元素
     - opacity 属性

   - 需要裁剪的地方也会单独生成一个图层

     裁剪就是需要滚动的地方，里面内容会单独生成一个图层。如果有滚动条，滚动条也会单独生成一个图层

5. 图层绘制

   在完成图层树的构建之后，渲染引擎**主线程**会对每个图层进行绘制。这里说的绘制不是真正的绘制画面，而是生成一个绘制指令列表。

   将每个图层的绘制拆分成多个绘制指令，传给**合成线程**。

6. 栅格化

   绘制指令生成之后，渲染进程**主线程**会将绘制指令发送给**合成线程**，由合成线程来完成最后的绘制工作。合成线程会将图层划分为**图块**。

7. 合成和显示

   等所有图块都被栅格化，**合成线程**会收集位图信息来创建**合成帧**。合成帧随后会通过 IPC 协议将消息传给**浏览器主进程**。浏览器主进程收到消息后，会将页面内容绘制到内存中，最后再将内存显示在屏幕上。

   ![img](https://tva1.sinaimg.cn/large/00831rSTly1gcxdow0t7sj30w20ds3zh.jpg)

### [3.3. 什么是TCP三次握手？]

TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个数据包

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcxdw1ieruj30u00vfmza.jpg)

ACK：确认有效，确认序号。 SYN：发起一个新连接。

> 你招手
>
> 妹子点头微笑并招手
>
> 你点头微笑

### [3.4. 为什么要三次握手？]

客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

### [3.5 什么是TCP四次挥手？]

TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作。

![img](https://tva1.sinaimg.cn/large/00831rSTly1gcxe17p0koj30ve0lcdix.jpg)

Fin：释放连接

ACK：确认有效，确认序号。

SYN：发起一个新连接。

Seq: 序号。

### [3.6 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？]

TCP 是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。